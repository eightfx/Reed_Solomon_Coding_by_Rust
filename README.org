* これは何？
RustでReed-Solomon符号を実装してみました。
Reed-Solomon符号は、データの送受信時にエラーが発生した場合に、データを復元するための符号です。

* 使い方
1. まずRustをインストールします。

2. このリポジトリをクローンします。

3. クローンしたディレクトリに移動して、cargo run --releaseを実行します。

4. 以下のような出力が得られます。ただし、エラーはランダムに発生するので、実行するたびに出力が異なります。


成功した場合:
#+begin_src output
[16,8,9]-_17code
送信したい文章: [0, 0, 0, 0, 0, 0, 0, 1]
送信語:[1, 11, 2, 5, 4, 10, 8, 3, 16, 6, 15, 12, 13, 7, 9, 14]
エラーの数:2
受信語: [1, 11, 2, 4, 4, 10, 8, 3, 16, 7, 15, 12, 13, 7, 9, 14]
復号:[1, 11, 2, 5, 4, 10, 8, 3, 16, 6, 15, 12, 13, 7, 9, 14]
正解

#+end_src

失敗した場合:
 #+begin_src output
[16,8,9]-_17code
送信したい文章: [0, 0, 0, 0, 0, 0, 0, 1]
送信語:[1, 11, 2, 5, 4, 10, 8, 3, 16, 6, 15, 12, 13, 7, 9, 14]
エラーの数:9
受信語: [1, 2, 2, 5, 4, 8, 16, 3, 8, 5, 15, 13, 13, 7, 9, 14]
復号不可能
 #+end_src

* 理論的背景

$$ P = \{\alpha_1, \ldots, \alpha_n\} \subset \mathbb{F}_q $$

$$ L(m) : \mathbb{F}_q を係数とする最大m次の1変数多項式からなる線形空間とする。$$

$$ ただし、実務上はPを  \mathbb{F}_q  の原始根の集合(i.e. n = q - 1 )として扱うことが多い。$$

$$ n > mとする。$$

$$ Ev :  L(m) \rightarrow L(n) : f \longmapsto (f(\alpha_1), \ldots , f(\alpha_n)) とする。$$

$$ この写像は単射で、像は次数mのReed-Solomon codeと呼ばれる  [n,m+1,n-m]_q -code となる。$$

$$ 例えば、P = \{ x_1, \ldots, x_n \} として、送信したい文章を (r_1, \ldots, r_{m+1}) とする。$$

$$ u(x) = \sum r_i \cdot x^i とすると、文章は(u(x_1), \ldots, u(x_n))として符号化される。$$





